### 分布式一致性

#### ACID
    原子性（Actomicity）
    事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行 

    一致性（Consistent）
    在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。

    隔离性（Isolation）
    数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然（在不同的隔离级别下，InnoDB的锁机制和一致性读策略不同。）

    持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

#### CAP
    C：一致性 多个服务之间的数据是否强一致
    A：高可用 在一定时间内，是否可以获得响应结果 
    P：分区容错性  在比如由于网络原因导致了若干个集群被分割，导致彼此无法通信，是否还能保证一致性可高可用

    CAP只能同时保证两个：
        保证CP：一致性需要以牺牲性能为代价，有可能会由于要保持强一致性而导致响应被阻塞，因此会舍弃可用性A，例如分布式的数据库，如Redis，HBase，Zookeeper
        ---------------------------------
        保证AP：同上，高可用需要就需要避免由于一致性而产生的额外阻塞开销，因此会舍弃一致性C
        ---------------------------------
        保证CA：分布式集群中不存在这种情况，因为多个节点必定考虑主备同步，也就是网络，例如注册中心Eureka

#### BASE
    BA：Basically Available（基本可用）
    S：Soft state（软状态）
    E：Eventually consistent（最终一致性）

#### 分布式事务
    XA协议：
    在 XA 规范中，数据库充当 RM 角色，应用需要充当 TM 的角色，即生成全局的 txId ，调用 XAResource 接口，把多个本地事务协调为全局统一的分布式事务。
        2PC：
            第一阶段(pepare)：事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。
            第二阶段(commit/rollback)：事务协调器要求每个数据库提交数据，或者回滚数据。

            --
            开启 XA 全局事务后，所有子事务会按照本地默认的隔离级别锁定资源，并记录 undo 和 redo 日志。然后由 TM 发起 prepare 投票，询问所有的子事务是否可以进行提交：
                1.当所有子事务反馈的结果为 “yes” 时，TM 再发起 commit 。
                2.若其中任何一个子事务反馈的结果为“no”，TM 则发起 rollback 。
                3.如果在 prepare 阶段的反馈结果为 “yes” ，而 commit 的过程中出现宕机等异常时，则在节点服务重启后，可根据 XA recover 再次进行 commit 补偿，以保证数据的一致性。

            --
            1)单点问题：事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。
            2)同步阻塞：在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。
            3)数据不一致：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。
        3PC：

    TCC机制：
