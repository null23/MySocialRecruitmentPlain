### redis高可用：
   主从架构
   读写分离
   哨兵

### 主从架构：
    一个master，多个slave，slave从master上同步数据

### 读写分离：
    由于redis的使用场景一般都是读多写少，只在单机读的话，性能并不是很高。所以我们让master来负责写操作，然后把数据异步的同步至slave;让slave负责读操作，读取出的是从master同步过来的数据。
    注意这里master向slave同步数据的时候是异步操作的。

### 哨兵：
    哨兵是干嘛的
        当一个master宕机的时候，会从当前的slave中选举出来新的master。
        但是怎么知道一个master宕机了呢？以及如何选举出一个新的master呢？
        这就是哨兵来做的事情。

    哨兵是如何监控master宕机的？
        待完善

    哨兵的高可用
        至少需要三个哨兵
        两个哨兵出现的问题(majority是2才能故障转移，如果只有两个哨兵，那么只要有一个宕机了majority就会变为1，就无法故障转移了)
        哨兵的参数的配置:quorum(有几个哨兵认为master有问题才会故障转义切换slave)，majority(有几个哨兵存活的时候才能故障转移，2的majority=2，3的majority=2，5的majority=3，4的majority=2) 
        
        每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还得得到majority哨兵的授权，才能正式执行切换
        如果quorum < majority，比如5个哨兵，majority就是3，quorum设置为2，那么就3个哨兵授权就可以执行切换
        但是如果quorum >= majority，那么必须quorum数量的哨兵都授权，比如5个哨兵，quorum是5，那么必须5个哨兵都同意授权，才能执行切换

### redis数据丢失
    主从切换时，异步复制导致的数据丢失
        因为master -> slave的复制是异步的，所以可能有部分数据还没复制到slave，master就宕机了，此时这些部分数据就丢失了

    脑裂导致的数据丢失
        脑裂，也就是说，某个master所在机器突然脱离了正常的网络，跟其他slave机器不能连接，但是实际上master还运行着
        此时哨兵可能就会认为master宕机了，然后开启选举，将其他slave切换成了master
        这个时候，集群里就会有两个master，也就是所谓的脑裂
        此时虽然某个slave被切换成了master，但是可能client还没来得及切换到新的master，还继续写向旧master的数据可能也丢失了
        因此旧master再次恢复的时候，会被作为一个slave挂到新的master上去，自己的数据会清空，重新从新的master复制数据

### 解决异步复制和脑裂导致的数据丢失
        min-slaves-to-write 1
        min-slaves-max-lag 10

        要求至少有1个slave，数据复制和同步的延迟不能超过10秒
        如果说一旦所有的slave，数据复制和同步的延迟都超过了10秒钟，那么这个时候，master就不会再接收任何请求了
        上面两个配置可以减少异步复制和脑裂导致的数据丢失
            （1）减少异步复制的数据丢失
            有了min-slaves-max-lag这个配置，就可以确保说，一旦slave复制数据和ack延时太长，就认为可能master宕机后损失的数据太多了，那么就拒绝写请求，这样可以把master宕机时由于部分数据未同步到slave导致的数据丢失降低的可控范围内

            （2）减少脑裂的数据丢失
            如果一个master出现了脑裂，跟其他slave丢了连接，那么上面两个配置可以确保说，如果不能继续给指定数量的slave发送数据，而且slave超过10秒没有给自己ack消息，那么就直接拒绝客户端的写请求
            这样脑裂后的旧master就不会接受client的新数据，也就避免了数据丢失
            上面的配置就确保了，如果跟任何一个slave丢了连接，在10秒后发现没有slave给自己ack，那么就拒绝新的写请求
            因此在脑裂场景下，最多就丢失10秒的数据