### 请求特别慢
    请求特别慢可以分为好多慢的地方，大概如下：
    1.前端请求打到后端慢
    2.NG打满了，转发慢
    3.后端服务处理慢

    我们需要关心的地方，是后端服务处理的比较慢的情况。然而后端服务处理很慢也是有很多种情况的：
    1.看监控，看后端日志，看接口耗时，先看看到底是不是后端慢。如果慢，是哪个接口慢，这个接口是为啥慢？
      是代码逻辑有问题？
      是因为调用第三方服务，比如http接口，dubbo之类的，第三方回调慢？
      是因为mysql连接池打满了，导致无法获取到mysql的connection？

    2.先看CPU内存情况，找到占用内存多的进程，jstack 看下堆栈信息，是否频繁的进行Full GC，如果是的话看下内存快照，分析一下内存情况，看下线程信息，找到对应的方法名，找到有问题的代码
            大概的操作：
                1.top看下当前占内存的进程，一般就是tomcat，这一步是为了找到tomcat的进程号PID
                2.top -Hp tomcatPid 看下tomcat进程下占用内存多的线程，找到这个线程的PID
                3.使用jstack pid查看这个线程的堆栈信息，这个pid再堆栈信息中是16进制展示的
                4.jstack tomcat的进程pid | grep '占用cpu高的线程pid'
                5.dump下来
                6.使用MAT分析


      如果是磁盘满了，清理一下磁盘
      如果是带宽满了，找ops
    
    3.看下tomcat的线程池是否打满了，先看下tomcat对应的那个端口号建立了多少tcp连接
      netstat -pan |grep '8081'  (查看端口号是8081的tomcat的tcp连接情况)
      tomcat线程池的默认是200个，阻塞队列是大小100的有界阻塞队列，这时候最多可以同时处理300个请求。
      然后在看下tomcat的server.xml配置，看下maxThreads配的多少，阻塞队列大小是多少，比如我们看到maxThreads是200个，但是netstat看到的连接有250个，那么tomcat肯定是处理不过来这么多请求的，剩下的50个请求都得在阻塞队列里等着。

    4.

### 服务没有响应，查看tomcat的netstat都是CLOSE_WAIT
  1.有可能是httpclient线程池打满了，原因是httpclient线程池处理的很多请求都处于CLOSE_WAIT状态，处理请求的线程迟迟无法释放资源，导致新来的请求都被阻塞了