#### 逃逸分析
    逃逸分析，本质是一种算法，它是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。
    在计算机语言编译器优化原理中，逃逸分析是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他过程或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。
**通俗一点说：在一个方法中的一个对象，被return返回，或者在当前方法中被当作参数调用了其他方法，此时这个对象是逃逸的。**
**如果这个对象的作用域/引用，只存在于当前方法中，那么这个对象是没有逃逸的。**

#### 逃逸的类型
    1.GlobalEscape（全局逃逸/线程逃逸）， 即一个对象的引用逃出了方法或者线程。例如，一个对象的引用是复制给了一个类变量，或者存储在在一个已经逃逸的对象当中，或者这个对象的引用作为方法的返回值返回给了调用方法。
    2.ArgEscape（参数级逃逸/方法逃逸），即在方法调用过程当中传递对象的应用给一个方法。这种状态可以通过分析被调方法的二进制代码确定。
    3.NoEscape（没有逃逸），一个可以进行标量替换的对象。可以不将这种对象分配在传统的堆上。

### 逃逸造成的影响
    1.对于没有逃逸的对象，其内存分布在当前线程对应的栈上

    2.消除同步，例如一个被synchorized修饰的方法，逃逸分析可以判断出某个需要被同步保护的对象，是否只被一个线程访问，如果是就取消对该对象的同步保护的操作。也就是synchorized锁优化的锁升级的过程的第一阶段：无锁阶段。
    
    3.标量替换/矢量替代。Java虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们就可以称为标量。相对的，如果一个数据可以继续分解，那它称为聚合量，Java中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化，可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。