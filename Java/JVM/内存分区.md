#### 虚拟机栈(方法栈)和本地方法栈
##### 虚拟机栈(方法栈)：
        1.虚拟机栈是线程隔离的，服务于Java线程，也就是一个线程对应一个虚拟机栈
        2.虚拟机栈和线程，栈帧的模型图
![虚拟机栈-线程-栈帧](https://raw.githubusercontent.com/null23/picture/master/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%A0%88%E5%B8%A7.png)
        (一个线程创建一个虚拟机栈，每个栈由一个一个栈帧组成，每个方法的调用就创建一个栈帧并且压入栈，执行结束就弹出)
        3.若栈帧压入的深度(方法调用的次数)过多，超过[整个]虚拟机栈的[一个完整的栈帧]允许的深度，就会抛出StackOverflowError异常，意味着栈溢出。
        JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用。
        4.若同时运行的线程的个数过多，超过[整个]虚拟机栈允许的个数(是否可以理解为广度?也就是完整栈帧的个数)，就会抛出OutOfMemoryError:unable to create new native thread 异常，意味着整个虚拟机栈内存耗尽。

### JVM中的栈和数据结构的栈的区别？为什么JVM使用栈，用别的不行么？
    1.首先，JVM中的栈是具体的内存区域，而数据结构中的栈是抽象的
    2.JVM中的栈有哪些？
        有两个地方：虚拟机栈(也叫方法栈)和操作数栈。
        虚拟机栈：
            虚拟机栈的元素是栈帧，当调用一个方法时，会把方法相关的局部变量表、操作数栈、方法返回地址等信息封装到栈帧中，把该栈帧入栈；当方法执行结束后，把该栈帧出栈。
        操作数栈：
            对方法中的局部变量进行计算的栈，比如计算a+b*c-d，操作数栈包含在栈帧中。
    3.为啥JVM使用栈这种数据结构？
        其实用其他的数据结构也行，但是函数调用的场景，完全符合栈的使用场景。
        a方法调用b方法，b方法调用c方法，其实肯定是c方法先执行完，然后把c方法返回的数据返回给b方法，然后再把c方法的栈帧弹出。
        b方法执行完，把b方法返回的数据给a方法，然后b方法的栈帧弹出虚拟机栈。

        从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。

##### 本地方法栈：
        服务于Native方法。
        本地方法栈的功能和特点类似于虚拟机栈，均具有线程隔离的特点以及都能抛出StackOverflowError和OutOfMemoryError异常。
        不同的是，本地方法栈服务的对象是JVM执行的native方法，而虚拟机栈服务的是JVM执行的java方法。如何去服务native方法？native方法使用什么语言实现？怎么组织像栈帧这种为了服务方法的数据结构？虚拟机规范并未给出强制规定，因此不同的虚拟机实可以进行自由实现，我们常用的HotSpot虚拟机选择合并了虚拟机栈和本地方法栈。


#### 堆内存和堆外内存：
##### 堆外内存：
        线程不在堆内存上创建，线程在堆内存之外的内存上创建。
        OOM-unable to create new native thread这种异常，就是堆外内存不够时产生的，不停的创建线程就会导致这种情况的发生。

        出现了堆外内存溢出的情况，如何解决？
        1.先看代码逻辑，为什么会不断创建线程？
        2.查看操作系统每个进程的最大线程数：使用ulimit -u命令查看操作系统对于每个进程创建的线程个数的限制，如果太小了就修改下操作系统线程数阈值
        3.减少堆内存：系统总内存6G，堆内存分配了5G，永久代512M。在这种情况下，JVM占用了5.5G内存，系统进程、其他用户进程和线程将共用剩下的0.5G内存，很有可能没有足够的可用内存创建新的线程。如果是这种情况，考虑减小堆内存。(系统总内存固定，但是Java进程占用的内存不固定，只是最大值时6G)
        4.减少进程数：这和减小堆内存原理相似。考虑如下场景：系统总内存32G，java进程数5个，每个进程的堆内存6G。在这种情况下，java进程总共占用30G内存，仅剩下2G内存用于系统进程、其他用户进程和线程，很有可能没有足够的可用内存创建新的线程。如果是这种情况，考虑减少每台机器上的进程数。
        5.减小线程栈大小：线程会占用内存，如果每个线程都占用更多内存，整体上将消耗更多的内存。每个线程默认占用内存大小取决于JVM实现。可以利用-Xss参数限制线程内存大小，降低总内存消耗。例如，JVM默认每个线程占用1M内存，应用有500个线程，那么将消耗500M内存空间。如果实际上256K内存足够线程正常运行，配置-Xss256k，那么500个线程将只需要消耗125M内存。（注意，如果-Xss设置的过低，将会产生java.lang.StackOverflowError错误）

##### 可以创建线程数的计算公式
        (MaxProcessMemory - JVMMemory – ReservedOsMemory) / (ThreadStackSize) = Number of threads 

#### 被移除的方法区/永久代
    方法区 = 运行时常量池 + MetaSpace元空间

#### MetaSpace元空间(使用直接内存/堆外内存)：
    元空间是一个用于代替永久代的新的内存空间，元空间的内存不占用JVM的内存大小，而是使用操作系统的内存，也就是直接内存。
    因此元空间的大小受限于本机内存容量的大小的限制。

##### 元空间用来存啥
    类加载器加载类之后的类的信息，.class文件

##### 元空间的垃圾回收
    如果类元数据的空间占用达到参数“MaxMetaspaceSize”设置的值，将会触发对死亡对象和类加载器的垃圾回收。 

##### 对堆空间的影响
    取消了永久代之后，有一些原本存在于永久代的数据被迁移到堆空间，比如字符串常量池。
    字符串常量池在堆内存中，也就是String在堆内存中。

##### 元空间的OOM
    OutOfMemoryError：MetaSpace


**占用的内存 = JVM内存大小 + 元空间内存大小 + 线程创建的消耗的OS的内存大小**
**堆外内存/直接内存 = 元空间内存 + 线程创建的消耗的OS的内存大小**
ps：我记得JVM每创建一个线程，OS也创建一个线程，忘记了咋回事，记得看下