1.HashMap扩容1.7和1.8的扩容：红黑树，头插法，尾插法。头插法在多线程场景下的死链，环形链表。

2.Java中的不同的引用，可以结合ThreadLocal的弱引用

3.平时了解哪些技术是牺牲了一致性来保证可用性的，我说消息队列，他问我MySQL是不是，我说MySQL主从复制应该是。

4.可感知的线程中断：来自 Object 类的 wait()、wait(long)、wait(long, int)，
                    来自 Thread 类的 join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)

5.堆外内存：线程创建之后，在内存的哪个部分

6.JVM-TLAB

7.一般情况下，发生OOM的线程都会终结(该线程的所有对象也会被垃圾回收)，除非代码写的太烂。比如显示捕获到OOM异常之后，手动阻塞当前线程，导致该线程持有的Java对象无法得到释放

8.一个对象一定被创建在堆内存中吗？结合逃逸分析，如果这个对象的引用，作用域，仅仅存在于一个方法中，那么这个对象是存在于此方法对应的栈上的，占用的是栈的内存。

9.