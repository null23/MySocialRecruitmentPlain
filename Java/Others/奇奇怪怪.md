1.HashMap扩容1.7和1.8的扩容：红黑树，头插法，尾插法。头插法在多线程场景下的死链，环形链表。

2.Java中的不同的引用，可以结合ThreadLocal的弱引用

3.平时了解哪些技术是牺牲了一致性来保证可用性的，我说消息队列，他问我MySQL是不是，我说MySQL主从复制应该是。

4.可感知的线程中断：来自 Object 类的 wait()、wait(long)、wait(long, int)，
                    来自 Thread 类的 join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)

5.堆外内存：线程创建之后，在内存的哪个部分

6.JVM-TLAB

7.一般情况下，发生OOM的线程都会终结(该线程的所有对象也会被垃圾回收)，除非代码写的太烂。比如显示捕获到OOM异常之后，手动阻塞当前线程，导致该线程持有的Java对象无法得到释放

8.一个对象一定被创建在堆内存中吗？结合逃逸分析，如果这个对象的引用，作用域，仅仅存在于一个方法中，那么这个对象是存在于此方法对应的栈上的，占用的是栈的内存。

9.Redis为什么这么快？
    1.基于内存
    2.单线程。单线程的好处有一点就是，避免上下文的切换。上下文的频繁切换，也是多线程编程的瓶颈。
    3.数据结构简单，操作简单
    4.使用多路IO复用模型，非阻塞IO

10.为什么要分为堆和栈？从不同的角度去分析？

11.堆大还是栈大？

12.JVM的总内存如何计算？既然堆的大小是已经可以根据-Xmx来确定了，那么栈会占用的内存大小如何计算？