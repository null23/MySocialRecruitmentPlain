#### 1. 什么是线程安全性？
	线程安全的定义中，最核心的概念就是“正确性”，所谓正确性，就是某各类的行为和其规范一致。
	当多个线程访问某各类的时候，这个类始终都能表现出正确的行为，那么这个类就是线程安全的。
	ps：无状态对象(例如Servlet对象)一定是线程安全的。

#### 2. Java中的线程安全
	为了更深入的理解线程安全，我们可以不把线程安全当做一个非真既假的排他项，我们可以把Java中的线程安全按照“安全程度”的强弱来进行排序。
		2.1 不可变
			final关键字修饰的类
		2.2 绝对线程安全
			绝对线程安全=满足线程安全，事实上Java中的大部分类，都不是一个绝对线程安全的类，比如：Vector，HashTable等。
			譬如：a操作是线程安全的，b操作是线程安全的，但是b操作的结果依赖于a操作的结果。	
			很明显，在这个“依赖”的过程中，我们并没有满足a操作和b操作“依赖”之间的的原子性，因此我们也不能称之为绝对线程安全。
		2.3 相对线程安全
			通常意义上讲的线程安全，这个对象的单独的操作是线程安全的，我们就可以称他为相对线程安全，看下绝对线程安全就懂了。
		2.4 线程兼容
			对象本身并不线程安全，但是我们作为使用方，通过一些“外力”，让我们对他的操作是线程安全的。
		2.5 线程对立

#### 3.互斥同步
	3.1 synchronized关键字
		synchronized的作用：
			多个线程能够互斥的访问一个代码块
			多个线程共享的变量的修改，及时可见
			避免指令重排序

		synchronized的用法：
			修饰代码块
				synchronized(this) 对象锁
				synchronized(obj) 对象锁
			修饰方法
				调用该方法的对象的对象锁 
			修饰静态方法
				类锁
			修饰类

#### 4. 原子性
	i++并不是原子性的，包含了 读取-修改-写入三个操作。
	2.1 竞态条件
		先检查后执行，问题的关键在于检查本身就已经是失效的了
	2.2 加锁机制
		1.使用AtomicLong或者AtomicReference(一种替代对象引用的线程安全类)。
	2.3 内置锁
		synchronized，互斥锁，同时只能有一个线程访问，其他线程会一直阻塞等待。
	2.4 重入
