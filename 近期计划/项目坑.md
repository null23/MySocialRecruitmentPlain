1.ES打分

2.ES刷新有1s延迟，此时查询时旧数据，删除缓存后再放入缓存，缓存里的是脏数据
    其实由此可以引申出redis和mysql一致性的问题

3.洗数用主键判断id>n,limit 10，而不是直接limit index,pageSize

4.父类和子类用BeanUtils拷贝的时候

5.记一次OOM：无界阻塞队列，HDFS加载到内存数据2600w：spark解析hdfs，然后数据导入es

6.在beta单机环境缓存用户信息，使用的是GuavaCache，看起来并没有问题。切换到生产环境一开始也没问题，后来突然发现有用户更新了信息后mysql和展示的信息不一致的情况，后来发现是因为生产环境是分布式的，GuavaCache依托于Java内存，多台机器无法同步。生产环境一开始没有问题的原因是：我们采用的ng hash的方式是通过ip hash，在公司内网测试的时候请求都是打到同一台机器上的，后来有其他地方的用户大量请求才让我们发现了这个问题。

7.lambda表达式吞异常，无法直接显示抛出

8.调用同一个类中的方法，事务失效

9.素材中心，不同的模块拥有相同的功能点，所以采用策略模式，设计一个顶层接口，不同的模块都去实现它

10.普通的定时任务，只会轮询随机到一台机器执行。
    多台机器执行定时任务，采用广播的方式，把所有部署的机器的定时任务开始执行。此时需要采用hash的策略，比如根据业务主键的id，和ip进行hash，来判断当前机器是否可以执行。

11.洗数遇到的故障：
    根据主键id作为startId(startId自增，取集合的最后一个元素的id)洗数，但是又把update_time作为了排序的条件，导致每次得到的startId并不是正规递增的。
    比如第一次startId是，第二次的根据update_time排序的startId仍然是0，这是非常可能存在的，就导致无限的死循环。

12.如何查看机器指标？有哪些指标？分别能说明什么问题？

13.mysql死锁
    事务A：insert  tb_A    1
           update  tb_A    2
    事务B：insert  tb_A    3 
           update  tb_A    4

    在1操作和2操作的时候，会给被insert的那条数据的相关索引项加锁
    但是我们并没有给2,4的update操作添加索引项，因此此处的update走的是表锁
    于是2,4的update操作，会等待1,4处的行锁，导致死锁

    解决：对update操作的where条件添加联合索引

    PS：RR可重复读隔离级别下，mysql会使用范围锁的行锁算法，我们公司使用的是RR可重复读隔离级别
    改进：仅仅是对update操作的where条件添加联合索引，由于我司的RR隔离级别，会产生间隙锁，因此我们先把update的那条数据的id查询出来，根据id更新，这样走的就是行锁，减小的锁的粒度，更大程度的避免了死锁的发生。
    
14.redis分布式锁抢占，设置的超时时间太短，导致不该抢占成功的人抢占到了
    1.守护线程
    2.Redisson
    3.超长超时时间，finally中释放锁

15.和上边的类似的问题，外呼没有回调，永远都无法主动释放锁，只能等到超时时间结束，怎么办？
    1.定时任务？